(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = batch;
function batch(action, {
  size = 1,
  wait = Infinity
}) {
  let timeout = null;
  let current = [];
  return params => {
    const batch = current;
    const send = async () => {
      Promise.resolve(action(batch.map(it => it.params))).then(results => {
        results.forEach((result, i) => {
          batch[i].resolve(result);
        });
      });
    };
    return new Promise((resolve, reject) => {
      batch.push({
        resolve,
        params,
        reject
      });
      if (batch.length === size) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        send();
        current = [];
      } else if (!timeout && wait !== Infinity) {
        timeout = setTimeout(function () {
          // check if batch already sent
          if (current === batch) {
            current = [];
            clearTimeout(timeout);
            timeout = null;
            send();
          }
        }, wait);
      }
    });
  };
}
},{}],2:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = batchcall;
var _serialize = _interopRequireDefault(require("./serialize.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/**
 *
 * @param {*} it
 * @param {{ params, method }[]} batch
 * @param {*} param2
 * @returns
 */
function batchcall(it, batch, {
  debug_level = 0
} = {}) {
  let all_params_functions = {};

  // pre-process and serialize requests
  const requests = batch.map(({
    id,
    method,
    params
  }) => {
    if (typeof id !== "number") id = Math.random();
    const [params_serialized, params_functions] = (0, _serialize.default)(params || [], "microlink.call:");
    Object.assign(all_params_functions, params_functions);
    return {
      jsonrpc: "2.0",
      id,
      method,
      params: params_serialized
    };
  });
  if (debug_level >= 2) console.log("[microlink.batchcall] requests serialized to ", requests);
  const ids = requests.map(req => req.id);
  return new Promise(resolve => {
    const listener = async function listener(evt) {
      if (debug_level >= 2) {
        console.log("[microlink.batchcall] response listener received message event with data", evt.data);
      }
      let {
        data
      } = evt;
      if (typeof data !== "object" || data === null) return;

      // worker is requesting that the main thread run a function for it
      if (data.jsonrpc === "2.0" && data.method && data.method in all_params_functions) {
        if (!Array.isArray(data.params)) throw Error("[microlink.batchcall] params should be an array");
        const result = await all_params_functions[data.method](...data.params);
        const msg = {
          jsonrpc: "2.0",
          result,
          id: data.id
        };
        if (debug_level >= 2) console.log("[microlink.batchcall] posting message down to worker:", msg);
        return it.postMessage(msg);
      }
      if (Array.isArray(data) && data.every(it => typeof it === "object" && ids.includes(it.id))) {
        if (debug_level >= 2) console.log("[microlink.batchcall] removing exhausted listener");
        it.removeEventListener("message", listener);

        // enable garbage collection of params
        // even if promise is used later
        all_params_functions = null;

        // sort output results by input order
        data.sort((a, b) => Math.sign(ids.indexOf(a.id) - ids.indexOf(b.id)));
        const results = data.map(res => res.result);
        if (debug_level >= 2) console.log("[microlink.batchcall] resolving batch call:", results);
        resolve(results);
      }
    };
    it.addEventListener("message", listener);
    if (debug_level >= 2) console.log("[microlink.batchcall] posting message down to worker:", requests);
    return it.postMessage(requests);
  });
}
},{"./serialize.js":9}],3:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = call;
var _serialize = _interopRequireDefault(require("./serialize.js"));
var _deserialize = _interopRequireDefault(require("./deserialize.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function call(it, method, params, {
  debug_level = 0
} = {}) {
  if (!params) params = [];
  let [params_serialized, params_functions] = (0, _serialize.default)(params);
  if (debug_level >= 2) {
    console.log("[microlink.call] serialized to ", [params_serialized, params_functions]);
  }
  return new Promise((resolve, reject) => {
    const id = Math.random();
    const listener = async function listener(evt) {
      if (debug_level >= 2) {
        console.log("[microlink.call] response listener received message event with data", evt.data);
      }
      let {
        data
      } = evt;
      if (typeof data !== "object" || data === null) {
        return;
      }

      // batch request
      if (Array.isArray(data) && data.length >= 1 && data[0].jsonrpc === "2.0" && data[0].method) {
        if (debug_level >= 2) console.log("[microlink.call] top thread received batch request");
        if (!params_functions) throw new Error("[microlink.call] no callable functions");
        // const times = []
        const results = await Promise.all(data.map(async req => {
          // if (!req.method) throw new Error("[Microlink.call] missing method");
          // if (!(req.method in params_functions)) throw new Error("[Microlink.call] invalid method");
          const result = await params_functions[req.method](...req.params);
          return {
            jsonrpc: "2.0",
            result,
            id: req.id
          };
        }));
        if (debug_level >= 2) console.log("[microlink.call] top thread posting results to worker:", results);
        return it.postMessage(results);
      }
      if (data.jsonrpc !== "2.0") {
        return;
      }
      if (data.method && params_functions && data.method in params_functions) {
        try {
          if (!Array.isArray(data.params)) throw Error("[microlink.call] params should be an array");
          const result = await params_functions[data.method](...data.params);
          const msg = {
            jsonrpc: "2.0",
            result,
            id: data.id
          };
          if (debug_level >= 2) console.log("[microlink.call] posting message down to worker:", msg);
          return it.postMessage(msg);
        } catch (error) {
          console.error("[microlink.call] error:", error);
          reject(error);
        }
      }
      if (data.id === id) {
        it.removeEventListener("message", listener);

        // enable garbage collection of params
        // even if promise is used later
        params_functions = null;
        const result = (0, _deserialize.default)(it, data.result);
        if (debug_level >= 2) {
          console.log("[microlink.call] deserialized", data.result, "to", result);
        }
        resolve(result);
      }
    };
    it.addEventListener("message", listener);
    const msg = {
      jsonrpc: "2.0",
      id,
      method,
      params: params_serialized
    };
    if (debug_level >= 3) console.log("[microlink.call] posting message down to worker:", msg);
    return it.postMessage(msg);
  });
}
},{"./deserialize.js":4,"./serialize.js":9}],4:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = deserialize;
var _batch = _interopRequireDefault(require("./batch.js"));
var _batchcall = _interopRequireDefault(require("./batchcall.js"));
var _enums = require("./enums.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// const cache = {};

function deserialize(it, inpt, depth = 1, {
  batch_size = 1,
  batch_wait = 10,
  debug_level = 0
} = {}) {
  if (Array.isArray(inpt)) {
    if (depth >= 0) {
      return inpt.map(param => deserialize(it, param, depth - 1, {
        batch_size,
        batch_wait
      }));
    } else {
      return inpt;
    }
  } else if (typeof inpt === "object" && inpt !== null && inpt.constructor.name.indexOf("Array") === -1) {
    const obj = {};
    for (let key in inpt) {
      obj[key] = deserialize(it, inpt[key], depth - 1, {
        batch_size,
        batch_wait
      });
    }
    return obj;
  } else if (typeof inpt === "string" && inpt.startsWith(_enums.DEFAULT_FUNCTION_PREFIX)) {
    const method = inpt.replace(_enums.DEFAULT_FUNCTION_PREFIX, "");
    const runInBatch = (0, _batch.default)(params => {
      return (0, _batchcall.default)(it, params, {
        debug_level
      });
    }, {
      size: batch_size,
      wait: batch_wait
    });
    return function () {
      const params = Array.from(arguments);
      return runInBatch({
        method,
        params
      });
    };
    // return async function () {
    //   const params = Array.from(arguments);
    //   // const str = JSON.stringify(params); // adding overhead??
    //   // if (!(str in cache)) {
    //   //   cache[str] = runInBatch({ method, params });
    //   // }
    //   // return cache[str];
    //   return runInBatch({ method, params });
    // };
  } else if (typeof inpt === "string" && inpt.startsWith(_enums.DEFAULT_PROMISE_PREFIX)) {
    const method = inpt.replace(_enums.DEFAULT_PROMISE_PREFIX, "");
    const runInBatch = (0, _batch.default)(params => {
      return (0, _batchcall.default)(it, params, {
        debug_level
      });
    }, {
      size: batch_size,
      wait: batch_wait
    });
    return runInBatch({
      method,
      params: []
    });
  } else {
    return inpt;
  }
}
},{"./batch.js":1,"./batchcall.js":2,"./enums.js":5}],5:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_PROMISE_PREFIX = exports.DEFAULT_FUNCTION_PREFIX = void 0;
const DEFAULT_FUNCTION_PREFIX = exports.DEFAULT_FUNCTION_PREFIX = "microlink.function:";
const DEFAULT_PROMISE_PREFIX = exports.DEFAULT_PROMISE_PREFIX = "microlink.promise:";
},{}],6:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InternalError = InternalError;
exports.MethodNotFound = MethodNotFound;
function InternalError({
  error,
  id
}) {
  return {
    jsonrpc: "2.0",
    error: {
      code: -32603,
      message: "Internal error",
      data: {
        error: error.message
      }
    },
    id
  };
}
function MethodNotFound({
  id,
  method
}) {
  return {
    jsonrpc: "2.0",
    error: {
      code: -32601,
      message: "Method not found",
      data: {
        method
      }
    },
    id
  };
}
},{}],7:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = expose;
var _deserialize = _interopRequireDefault(require("./deserialize.js"));
var _serialize = _interopRequireDefault(require("./serialize.js"));
var _enums = require("./enums.js");
var _errors = require("./errors.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function expose(obj, options) {
  let batch_size = options && typeof options.batch_size === "number" ? options.batch_size : 1;
  let batch_wait = options && typeof options.batch_wait === "number" ? options.batch_wait : Infinity; // 10ms
  const debug_level = options && options.debug_level;
  const all_funcs = {};
  const onmessage = async evt => {
    let {
      data
    } = evt;
    if (debug_level >= 2) console.log("[microlink.expose] received message data", data);
    if (Array.isArray(data) && data.length >= 1 && data[0].jsonrpc === "2.0" && data[0].method) {
      if (debug_level >= 2) console.log("[microlink.call] top thread received batch request");
      if (!all_funcs) throw new Error("[microlink.call] no callable functions");
      const results = await Promise.all(data.map(async req => {
        if (typeof all_funcs[req.method] !== "function") {
          return (0, _errors.MethodNotFound)({
            id: req.id,
            method: req.method
          });
        }
        try {
          const result = await all_funcs[req.method](...req.params);
          return {
            jsonrpc: "2.0",
            result,
            id: req.id
          };
        } catch (error) {
          return (0, _errors.InternalError)({
            id,
            error
          });
        }
      }));
      if (debug_level >= 2) console.log("[microlink.call] exposed thread posting results to main thread:", results);
      return postMessage(results);
    }
    if (typeof data !== "object") return;
    if (data.jsonrpc !== "2.0") return;
    if (!data.method) return;
    const {
      id,
      method,
      params
    } = evt.data;
    if (method === "microlink.list") {
      if (debug_level >= 2) console.log("[microlink.expose] posting method names", data);
      return postMessage({
        jsonrpc: "2.0",
        result: Object.keys(obj),
        id
      });
    }
    if (typeof obj[method] !== "function") {
      if (debug_level >= 2) console.error("[microlink.expose] method not found: " + method);
      return postMessage((0, _errors.MethodNotFound)({
        id,
        method
      }));
    }
    try {
      // batching applies to messsages posted up
      const deserialized_params = (0, _deserialize.default)(self, params, 2, {
        batch_size,
        batch_wait
      });
      const result = await obj[method](...deserialized_params);
      const [serialized_result, funcs] = (0, _serialize.default)(result, {
        function_prefix: _enums.DEFAULT_FUNCTION_PREFIX,
        promise_prefix: _enums.DEFAULT_PROMISE_PREFIX
      });
      if (debug_level >= 2) console.log("[microlink.expose]", method, "result", result, "serialized to", [serialized_result, funcs]);
      Object.assign(all_funcs, funcs);

      // encode result in case it returns a function or promise

      if (debug_level >= 2) console.log("[microlink.expose] posting serialized result for " + method + ": " + JSON.stringify(serialized_result));
      return postMessage({
        jsonrpc: "2.0",
        result: serialized_result,
        id
      });
    } catch (error) {
      console.error("[microlink.expose] error:", error);
      return postMessage((0, _errors.InternalError)({
        error,
        id
      }));
    }
  };

  // unblock main thread of worker
  addEventListener("message", evt => {
    setTimeout(() => onmessage(evt), 0);
  });
}
},{"./deserialize.js":4,"./enums.js":5,"./errors.js":6,"./serialize.js":9}],8:[function(require,module,exports){
"use strict";

var _expose = _interopRequireDefault(require("./expose.js"));
var _serialize2 = _interopRequireDefault(require("./serialize.js"));
var _wrap = _interopRequireDefault(require("./wrap.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
if (typeof window === "object") {
  window.microlink = {
    expose: _expose.default,
    wrap: _wrap.default,
    _serialize: _serialize2.default
  };
}
if (typeof self === "object") {
  self.microlink = {
    expose: _expose.default,
    wrap: _wrap.default,
    _serialize: _serialize2.default
  };
}
if (typeof module === "object") {
  module.exports = {
    expose: _expose.default,
    wrap: _wrap.default,
    _serialize: _serialize2.default
  };
}
if (typeof define === "function" && define.amd) {
  define(function () {
    return {
      expose: _expose.default,
      wrap: _wrap.default,
      _serialize: _serialize2.default
    };
  });
}
},{"./expose.js":7,"./serialize.js":9,"./wrap.js":10}],9:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = serialize;
var _enums = require("./enums.js");
/**
 * @name serialize
 * @description convert functions and promises at any level of nesting to strings
 * @param {any} it
 * @param {String} prefix - add to beginning of function ids
 * @returns [it, funcs]
 */
function serialize(things, {
  function_prefix = _enums.DEFAULT_FUNCTION_PREFIX,
  promise_prefix = _enums.DEFAULT_PROMISE_PREFIX
} = {}, generate_id) {
  const funcs = {};
  const proms = {};
  if (!generate_id) generate_id = () => Math.random();
  function stringify(it) {
    if (Array.isArray(it)) {
      return it.map(i => stringify(i));
    } else if (typeof it === "function") {
      const fid = generate_id(it);
      funcs[fid] = it;
      return function_prefix + fid;
    } else if (typeof it === "object" && it !== null && typeof it.then === "function") {
      const pid = generate_id(it);
      proms[pid] = it;
      funcs[pid] = () => it; // create function that returns the promise
      return promise_prefix + pid;
    } else if (typeof it === "object" && it !== null && it.constructor.name.indexOf("Array") === -1) {
      // object that is not null nor a typed array
      return Object.fromEntries(Object.entries(it).map(([k, v]) => [k, stringify(v)]));
    } else {
      return it;
    }
  }
  things = stringify(things);
  return [things, funcs, proms];
}
},{"./enums.js":5}],10:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = wrap;
var _call = _interopRequireDefault(require("./call.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/**
 * @name wrap
 * @param {Object} worker
 * @param {Object} options
 * @param {Number} options.batch_size
 * @param {Number} options.debug_level
 * @returns {Object} wrapped object
 */
async function wrap(worker, {
  debug_level = 0
} = {}) {
  const obj = {};
  const methods = await (0, _call.default)(worker, "microlink.list", undefined, {
    debug_level
  });
  if (debug_level >= 2) console.log("[microlink.wrap] methods:", methods);
  methods.forEach(method => {
    obj[method] = (...params) => {
      if (debug_level >= 2) console.log("[microlink.wrap] called worker." + method);
      return (0, _call.default)(worker, method, params, {
        debug_level
      });
    };
  });
  return obj;
}
},{"./call.js":3}]},{},[8]);
