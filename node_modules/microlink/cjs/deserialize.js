"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = deserialize;
var _batch = _interopRequireDefault(require("./batch.js"));
var _batchcall = _interopRequireDefault(require("./batchcall.js"));
var _enums = require("./enums.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// const cache = {};

function deserialize(it, inpt, depth = 1, {
  batch_size = 1,
  batch_wait = 10,
  debug_level = 0
} = {}) {
  if (Array.isArray(inpt)) {
    if (depth >= 0) {
      return inpt.map(param => deserialize(it, param, depth - 1, {
        batch_size,
        batch_wait
      }));
    } else {
      return inpt;
    }
  } else if (typeof inpt === "object" && inpt !== null && inpt.constructor.name.indexOf("Array") === -1) {
    const obj = {};
    for (let key in inpt) {
      obj[key] = deserialize(it, inpt[key], depth - 1, {
        batch_size,
        batch_wait
      });
    }
    return obj;
  } else if (typeof inpt === "string" && inpt.startsWith(_enums.DEFAULT_FUNCTION_PREFIX)) {
    const method = inpt.replace(_enums.DEFAULT_FUNCTION_PREFIX, "");
    const runInBatch = (0, _batch.default)(params => {
      return (0, _batchcall.default)(it, params, {
        debug_level
      });
    }, {
      size: batch_size,
      wait: batch_wait
    });
    return function () {
      const params = Array.from(arguments);
      return runInBatch({
        method,
        params
      });
    };
    // return async function () {
    //   const params = Array.from(arguments);
    //   // const str = JSON.stringify(params); // adding overhead??
    //   // if (!(str in cache)) {
    //   //   cache[str] = runInBatch({ method, params });
    //   // }
    //   // return cache[str];
    //   return runInBatch({ method, params });
    // };
  } else if (typeof inpt === "string" && inpt.startsWith(_enums.DEFAULT_PROMISE_PREFIX)) {
    const method = inpt.replace(_enums.DEFAULT_PROMISE_PREFIX, "");
    const runInBatch = (0, _batch.default)(params => {
      return (0, _batchcall.default)(it, params, {
        debug_level
      });
    }, {
      size: batch_size,
      wait: batch_wait
    });
    return runInBatch({
      method,
      params: []
    });
  } else {
    return inpt;
  }
}