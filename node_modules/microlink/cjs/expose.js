"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = expose;
var _deserialize = _interopRequireDefault(require("./deserialize.js"));
var _serialize = _interopRequireDefault(require("./serialize.js"));
var _enums = require("./enums.js");
var _errors = require("./errors.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function expose(obj, options) {
  let batch_size = options && typeof options.batch_size === "number" ? options.batch_size : 1;
  let batch_wait = options && typeof options.batch_wait === "number" ? options.batch_wait : Infinity; // 10ms
  const debug_level = options && options.debug_level;
  const all_funcs = {};
  const onmessage = async evt => {
    let {
      data
    } = evt;
    if (debug_level >= 2) console.log("[microlink.expose] received message data", data);
    if (Array.isArray(data) && data.length >= 1 && data[0].jsonrpc === "2.0" && data[0].method) {
      if (debug_level >= 2) console.log("[microlink.call] top thread received batch request");
      if (!all_funcs) throw new Error("[microlink.call] no callable functions");
      const results = await Promise.all(data.map(async req => {
        if (typeof all_funcs[req.method] !== "function") {
          return (0, _errors.MethodNotFound)({
            id: req.id,
            method: req.method
          });
        }
        try {
          const result = await all_funcs[req.method](...req.params);
          return {
            jsonrpc: "2.0",
            result,
            id: req.id
          };
        } catch (error) {
          return (0, _errors.InternalError)({
            id,
            error
          });
        }
      }));
      if (debug_level >= 2) console.log("[microlink.call] exposed thread posting results to main thread:", results);
      return postMessage(results);
    }
    if (typeof data !== "object") return;
    if (data.jsonrpc !== "2.0") return;
    if (!data.method) return;
    const {
      id,
      method,
      params
    } = evt.data;
    if (method === "microlink.list") {
      if (debug_level >= 2) console.log("[microlink.expose] posting method names", data);
      return postMessage({
        jsonrpc: "2.0",
        result: Object.keys(obj),
        id
      });
    }
    if (typeof obj[method] !== "function") {
      if (debug_level >= 2) console.error("[microlink.expose] method not found: " + method);
      return postMessage((0, _errors.MethodNotFound)({
        id,
        method
      }));
    }
    try {
      // batching applies to messsages posted up
      const deserialized_params = (0, _deserialize.default)(self, params, 2, {
        batch_size,
        batch_wait
      });
      const result = await obj[method](...deserialized_params);
      const [serialized_result, funcs] = (0, _serialize.default)(result, {
        function_prefix: _enums.DEFAULT_FUNCTION_PREFIX,
        promise_prefix: _enums.DEFAULT_PROMISE_PREFIX
      });
      if (debug_level >= 2) console.log("[microlink.expose]", method, "result", result, "serialized to", [serialized_result, funcs]);
      Object.assign(all_funcs, funcs);

      // encode result in case it returns a function or promise

      if (debug_level >= 2) console.log("[microlink.expose] posting serialized result for " + method + ": " + JSON.stringify(serialized_result));
      return postMessage({
        jsonrpc: "2.0",
        result: serialized_result,
        id
      });
    } catch (error) {
      console.error("[microlink.expose] error:", error);
      return postMessage((0, _errors.InternalError)({
        error,
        id
      }));
    }
  };

  // unblock main thread of worker
  addEventListener("message", evt => {
    setTimeout(() => onmessage(evt), 0);
  });
}