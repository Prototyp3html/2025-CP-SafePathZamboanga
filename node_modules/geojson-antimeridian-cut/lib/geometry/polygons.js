"use strict";

require("core-js/modules/es.array.flat");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.sort");

require("core-js/modules/es.array.unscopables.flat");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.splitMultiPolygon = exports.splitPolygon = void 0;

var _util = require("../util");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

/**
 * A Polygon GeoJSON object
 * @typedef {Object} Polygon
 * @property {string} type
 * @property {LinearRing[]} coordinates
 */

/**
 * A MultiPolygon GeoJSON object
 * @typedef {Object} MultiPolygon
 * @property {string} type
 * @property {LinearRing[][]} coordinates
 */

/**
 * An array of four or more coordinates that defines the boundary of a surface or a hole in a
 * surface. The first coordinate must be equivalent to the last.
 * @typedef {number[][]} LinearRing
 */

/**
 * @param {LinearRing} linearRing
 * @param {LinearRing[]} collector
 */
const splitLinearRing = (linearRing, collector) => {
  const crossings = (0, _util.crossingPoints)(linearRing);

  if (crossings.length === 0) {
    collector.push([linearRing]);
    return;
  } // Get two highest-latitude intersection points


  const [startIntersect, endIntersect] = crossings.map(i => [(0, _util.antimeridianIntersect)(linearRing[i], linearRing[i + 1]), i]).sort(([latA], [latB]) => latB - latA); // Traverse from first intersection and build 'left' polygon

  const leftRing = []; // Add the first point (the intersection point)

  let currentIndex = startIntersect[1] + 1;

  if (currentIndex === linearRing.length - 1) {
    currentIndex = 0;
  }

  let firstAfterIntersect = linearRing[currentIndex];
  leftRing.push([180 * Math.sign(firstAfterIntersect[0]), startIntersect[0]]);
  leftRing.push(linearRing[currentIndex]);

  while (currentIndex !== endIntersect[1]) {
    currentIndex += 1;

    if (currentIndex === linearRing.length - 1) {
      // End of ring, wrap around
      currentIndex = 0;
    }

    leftRing.push(linearRing[currentIndex]);
  }

  leftRing.push([180 * Math.sign(firstAfterIntersect[0]), endIntersect[0]]); // Traverse from second intersection and build 'right' polygon;

  const rightRing = [];
  currentIndex = endIntersect[1] + 1;

  if (currentIndex === linearRing.length - 1) {
    currentIndex = 0;
  }

  firstAfterIntersect = linearRing[currentIndex];
  rightRing.push([180 * Math.sign(firstAfterIntersect[0]), endIntersect[0]]);
  rightRing.push(linearRing[currentIndex]);

  while (currentIndex !== startIntersect[1]) {
    currentIndex += 1;

    if (currentIndex === linearRing.length - 1) {
      currentIndex = 0;
    }

    rightRing.push(linearRing[currentIndex]);
  }

  rightRing.push([180 * Math.sign(firstAfterIntersect[0]), startIntersect[0]]); // Duplicate first value at end to create a ring

  leftRing.push(leftRing[0]);
  rightRing.push(rightRing[0]);
  splitLinearRing(leftRing, collector);
  splitLinearRing(rightRing, collector);
};
/**
 * Splits a polygon's linear rings. The first ring in the list is treated as the outer loop. The
 * remaining rings, if they exist, are treated as holes. If the main ring is split, all holes are
 * added to all resulting polygons. If a hole is split, the resulting rings are also applied to all
 * top-level polygons.
 *
 * @param {LinearRing[]} rings A list of rings to spli
 * @returns {LinearRing[][]}
 */


const splitPolygonRingList = rings => {
  const [mainRing, ...holes] = rings;
  const rtn = []; // Split the main ring & push results into rtn value

  splitLinearRing(mainRing, rtn); // Split each hole and apply the cut holes to each resulting ring

  if (holes) {
    const cutHoles = [];
    holes.forEach(hole => splitLinearRing(hole, cutHoles));
    rtn.forEach(ring => cutHoles.flat().forEach(hole => ring.push(hole)));
  }

  return rtn;
};
/**
 * @param {Polygon} polygon
 * @returns {(MultiPolygon|Polygon)}
 */


const splitPolygon = polygon => {
  const {
    coordinates: linearRings,
    type: _type
  } = polygon,
        rest = _objectWithoutProperties(polygon, ["coordinates", "type"]);

  const cutPolygon = splitPolygonRingList(linearRings);
  return cutPolygon.length > 1 ? _objectSpread({
    type: 'MultiPolygon',
    coordinates: cutPolygon
  }, rest) : _objectSpread({
    type: 'Polygon',
    coordinates: cutPolygon.flat()
  }, rest);
};
/**
 * @param {MultiPolygon} multiPolygon
 * @returns {MultiPolygon}
 */


exports.splitPolygon = splitPolygon;

const splitMultiPolygon = multiPolygon => {
  const {
    coordinates: polygons,
    type: _type
  } = multiPolygon,
        rest = _objectWithoutProperties(multiPolygon, ["coordinates", "type"]);

  const rtn = polygons.map(polygon => splitPolygonRingList(polygon)).flat();
  return _objectSpread({
    type: 'MultiPolygon',
    coordinates: rtn
  }, rest);
};

exports.splitMultiPolygon = splitMultiPolygon;