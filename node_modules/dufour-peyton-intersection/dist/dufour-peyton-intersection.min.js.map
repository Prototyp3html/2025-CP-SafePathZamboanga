{"version":3,"file":"dufour-peyton-intersection.min.js","mappings":"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","sources":["webpack://dufour-peyton-intersection/./src/index.js","webpack://dufour-peyton-intersection/./node_modules/get-depth/index.js","webpack://dufour-peyton-intersection/./src/cluster.js","webpack://dufour-peyton-intersection/./src/calculate-ring.js","webpack://dufour-peyton-intersection/./src/range/sort.js","webpack://dufour-peyton-intersection/./src/round-down.js","webpack://dufour-peyton-intersection/./src/cluster-line-segments.js","webpack://dufour-peyton-intersection/./src/range/compare.js","webpack://dufour-peyton-intersection/./src/range/contains.js","webpack://dufour-peyton-intersection/./src/range/cut.js","webpack://dufour-peyton-intersection/./src/each-polygon.js","webpack://dufour-peyton-intersection/./src/calculate-core.js","webpack://dufour-peyton-intersection/./src/each-pair.js","webpack://dufour-peyton-intersection/./src/calculate.js","webpack://dufour-peyton-intersection/./src/range/overlaps.js","webpack://dufour-peyton-intersection/./src/couple.js","webpack://dufour-peyton-intersection/./src/calculate-polygon.js","webpack://dufour-peyton-intersection/./src/range/merge.js","webpack://dufour-peyton-intersection/./src/clamp.js","webpack://dufour-peyton-intersection/./src/categorize-intersection.js","webpack://dufour-peyton-intersection/./src/prepare-snap.js","webpack://dufour-peyton-intersection/./src/check-rows.js","webpack://dufour-peyton-intersection/./src/partition.js","webpack://dufour-peyton-intersection/./src/range/multicut.js","webpack://dufour-peyton-intersection/./src/range/merge-consecutive.js","webpack://dufour-peyton-intersection/./src/get-polygons.js","webpack://dufour-peyton-intersection/webpack/bootstrap","webpack://dufour-peyton-intersection/webpack/startup"],"sourcesContent":["\"use strict\";\n\nconst categorizeIntersection = require(\"./categorize-intersection.js\");\nconst clamp = require(\"./clamp.js\");\nconst cluster = require(\"./cluster.js\");\nconst clusterLineSegments = require(\"./cluster-line-segments.js\");\nconst calculate = require(\"./calculate.js\");\nconst calculateCore = require(\"./calculate-core.js\");\nconst couple = require(\"./couple.js\");\nconst eachPair = require(\"./each-pair.js\");\nconst eachPolygon = require(\"./each-polygon.js\");\nconst mergeRanges = require(\"./range/merge.js\");\nconst mergeConsecutiveRanges = require(\"./range/merge-consecutive.js\");\nconst partition = require(\"./partition.js\");\nconst prepareSnap = require(\"./prepare-snap.js\");\nconst rangeContains = require(\"./range/contains.js\");\nconst rangeCut = require(\"./range/cut.js\");\nconst carveHoles = require(\"./range/multicut.js\");\nconst rangeOverlap = require(\"./range/overlaps.js\");\nconst roundDown = require(\"./round-down.js\");\nconst rangeSort = require(\"./range/sort.js\");\n\nconst dufour_peyton_intersection = {\n  calculate,\n  calculateCore,\n  carveHoles,\n  categorizeIntersection,\n  clamp,\n  cluster,\n  clusterLineSegments,\n  couple,\n  eachPair,\n  eachPolygon,\n  mergeRanges,\n  mergeConsecutiveRanges,\n  partition,\n  prepareSnap,\n  rangeContains,\n  rangeCut,\n  rangeOverlap,\n  rangeSort,\n  roundDown\n};\n\nif (typeof define === \"function\" && define.amd) define(() => dufour_peyton_intersection);\nif (typeof module === \"object\") module.exports = dufour_peyton_intersection;\nif (typeof self == \"object\") self.dufour_peyton_intersection = dufour_peyton_intersection;\nif (typeof window == \"object\") window.dufour_peyton_intersection = dufour_peyton_intersection;\n","module.exports = function getDepth(arr) {\n  const isArray = (arr) =>\n    Array.isArray(arr) ||\n    arr instanceof Int8Array ||\n    arr instanceof Uint8Array ||\n    arr instanceof Uint8ClampedArray ||\n    arr instanceof Int16Array ||\n    arr instanceof Uint16Array ||\n    arr instanceof Int32Array ||\n    arr instanceof Uint32Array ||\n    arr instanceof Float32Array ||\n    arr instanceof Float64Array ||\n    arr instanceof BigInt64Array ||\n    arr instanceof BigUint64Array;\n\n  let depth = 0;\n  let part = arr;\n  while (isArray(part)) {\n    depth++;\n    part = part[0];\n  }\n  return depth;\n};\n","\"use strict\";\n\nmodule.exports = function cluster(items, newClusterTest) {\n  try {\n    const numberOfItems = items.length;\n    const clusters = [];\n    let cluster = [];\n    for (let i = 0; i < numberOfItems; i++) {\n      const item = items[i];\n      cluster.push(item);\n      if (newClusterTest(item)) {\n        clusters.push(cluster);\n        cluster = [];\n      }\n    }\n\n    if (cluster.length > 0) clusters.push(cluster);\n\n    return clusters;\n  } catch (error) {\n    console.error(\"[cluster]:\", error);\n  }\n};\n","\"use strict\";\nconst calculateCore = require(\"./calculate-core.js\");\nconst checkRows = require(\"./check-rows.js\");\nconst mergeConsecutiveRanges = require(\"./range/merge-consecutive.js\");\nconst rangeSort = require(\"./range/sort.js\");\n\nmodule.exports = function calculateRing({ debug_level = 0, raster_bbox, raster_height, raster_width, pixel_height, pixel_width, ring }) {\n  const [xmin, ymin, xmax, ymax] = raster_bbox;\n\n  if (raster_bbox.every(it => typeof it === \"string\")) {\n    throw new Error(\"[dufour-peyton-intersection] raster_bbox should be all numbers, not strings\");\n  }\n\n  if (pixel_height === undefined || pixel_height === null) pixel_height = (ymax - ymin) / raster_height;\n  if (pixel_width === undefined || pixel_width === null) pixel_width = (xmax - xmin) / raster_width;\n\n  const rows = [];\n  for (let i = 0; i < raster_height; i++) rows.push([]);\n\n  calculateCore({\n    debug_level,\n    raster_bbox,\n    raster_height,\n    raster_width,\n    pixel_height,\n    pixel_width,\n    ring,\n    per_row_segment: ({ row, columns }) => {\n      rows[row].push(columns);\n    }\n  });\n\n  for (let irow = 0; irow < rows.length; irow++) {\n    const ranges = rows[irow];\n    if (ranges) {\n      // sort from left to right\n      rangeSort(ranges);\n\n      // replace existing row with sorted and merged one\n      rows[irow] = mergeConsecutiveRanges(ranges);\n    }\n  }\n\n  if (debug_level >= 2) checkRows(rows);\n\n  return rows;\n};\n","const compare = require(\"./compare.js\");\n\n/**\n * @name sort\n * @description sorts the given ranges and returns them.  this mutates the original input.\n * @param {Array<Range>} ranges\n * @returns {Array<Range>} sorted ranges\n */\nmodule.exports = function sort(ranges) {\n  return ranges.sort(compare);\n};\n","\"use strict\";\n\n/**\n * @name roundDown\n * @description like Math.round, but numbers in the middle are rounded down not up\n * @param {Number} n\n * @returns {Number} rounded number\n */\nmodule.exports = function roundDown(n) {\n  return -1 * Math.round(-1 * n);\n};\n","\"use strict\";\n\nconst cluster = require(\"./cluster.js\");\n\nmodule.exports = function clusterLineSegments(lineSegments, numberOfEdges, debug = false) {\n  try {\n    const clusters = cluster(lineSegments, s => s.endsOffLine);\n\n    const numberOfClusters = clusters.length;\n\n    if (numberOfClusters >= 2) {\n      const firstCluster = clusters[0];\n      const firstSegment = firstCluster[0];\n      const lastCluster = clusters[clusters.length - 1];\n      const lastSegment = lastCluster[lastCluster.length - 1];\n\n      // determine if the last segment should be added to the first\n      if (lastSegment.last_edge_in_ring && firstSegment.index === 0 && lastSegment.endsOnLine) {\n        clusters[0] = clusters.pop().concat(firstCluster);\n      }\n    }\n\n    return clusters;\n  } catch (error) {\n    console.error(\"[clusterLineSegments]\", error);\n  }\n};\n","/**\n * @name compare\n * @description compare two ranges, sorting from left to right (smaller to larger) by left edge, then right edge\n * @param {Range} a \n * @param {Range} b \n * @returns {Number} comparison, which can be -1, 1, or zero\n */\nmodule.exports = function compare (a, b) {\n  return Math.sign(a[0] - b[0]) || Math.sign(a[1] - b[1]);\n}\n","/**\n * @name contains\n * @description check if the first range contains the second range\n * @param {Range} a \n * @param {Range} b \n * @returns {Boolean} result\n */\nmodule.exports = function contains (a, b) {\n  return b[0] >= a[0] && b[1] <= a[1];\n}\n","const rangeOverlap = require(\"./overlaps.js\");\n\nmodule.exports = function cut(range, hole) {\n  if (!Array.isArray(range)) throw new Error(\"[cut] range is not an array: \" + JSON.stringify(range));\n\n  if (hole === undefined) return [range];\n\n  if (!Array.isArray(hole)) throw new Error(\"[cut] hole is not an array:\" + JSON.stringify(hole));  \n\n  if (!rangeOverlap(range, hole)) return [range];\n\n  const result = [];\n\n  // check if left-side extends past hole\n  if (range[0] < hole[0]) result.push([range[0], hole[0] - 1]);\n\n  // check if right-side extends past hole\n  if (range[1] > hole[1]) result.push([hole[1] + 1, range[1]]);\n\n  return result;\n};\n","\"use strict\";\n\nconst getDepth = require(\"get-depth\");\n\n// call callback function for each polygon in geojson\nmodule.exports = function eachPolygon(geojson, callback) {\n  if (geojson.type === \"FeatureCollection\") {\n    geojson.features.forEach(feature => eachPolygon(feature, callback));\n  } else if (geojson.type === \"GeometryCollection\") {\n    geojson.geometries.forEach(geometry => eachPolygon(geometry, callback));\n  } else if (geojson.type === \"Feature\") {\n    eachPolygon(geojson.geometry, callback);\n  } else if (geojson.type === \"Polygon\") {\n    eachPolygon(geojson.coordinates, callback);\n  } else if (geojson.type === \"MultiPolygon\") {\n    geojson.coordinates.forEach(polygon => {\n      callback(polygon);\n    });\n  } else if (Array.isArray(geojson)) {\n    const depth = getDepth(geojson);\n    if (depth === 4) {\n      geojson.forEach(polygon => {\n        callback(polygon);\n      });\n    } else if (depth === 3) {\n      callback(geojson);\n    } else if (depth === 2) {\n      callback([geojson]);\n    }\n  }\n};\n","\"use strict\";\nconst categorizeIntersection = require(\"./categorize-intersection.js\");\nconst clamp = require(\"./clamp.js\");\nconst couple = require(\"./couple.js\");\nconst clusterLineSegments = require(\"./cluster-line-segments.js\");\nconst eachPair = require(\"./each-pair.js\");\nconst mergeRanges = require(\"./range/merge.js\");\nconst partition = require(\"./partition.js\");\nconst prepareSnap = require(\"./prepare-snap.js\");\n\nmodule.exports = function calculateCore({\n  debug_level = 0,\n  raster_bbox,\n  raster_height, // number of rows of pixels in the raster\n  raster_width, // number of columns of pixels in the raster\n  pixel_height,\n  pixel_width,\n  ring, // array of points\n  per_pixel,\n  per_row_segment\n}) {\n  const [raster_xmin, raster_ymin, raster_xmax, raster_ymax] = raster_bbox;\n\n  // iterate through the list of polygon vertices, convert them to\n  // lines, and compute the intersections with each image row\n  const intersectionsByRow = [];\n  for (let i = 0; i < raster_height; i++) intersectionsByRow.push([]);\n\n  eachPair(ring, (edge, iedge) => {\n    const [startPoint, endPoint] = edge;\n    const [x1, y1] = startPoint;\n    const [x2, y2] = endPoint;\n\n    const direction = Math.sign(y2 - y1);\n    const horizontal = y1 === y2;\n    const vertical = x1 === x2;\n    const slope = (y2 - y1) / (x2 - x1);\n\n    const edgeY = y1;\n\n    const edgeYMin = Math.min(y1, y2);\n    const edgeYMax = Math.max(y1, y2);\n\n    let startLng, startLat, endLat, endLng;\n    if (x1 < x2) {\n      [startLng, startLat] = startPoint;\n      [endLng, endLat] = endPoint;\n    } else {\n      [startLng, startLat] = endPoint;\n      [endLng, endLat] = startPoint;\n    }\n\n    if (startLng === undefined) throw Error(\"startLng is \" + startLng);\n\n    // find the y values in the image coordinate space\n    const imageY1 = Math.round((raster_bbox[3] - 0.5 * pixel_height - startLat) / pixel_height);\n    const imageY2 = Math.round((raster_bbox[3] - 0.5 * pixel_height - endLat) / pixel_height);\n\n    // make sure to set the start and end points so that we are\n    // incrementing upwards through rows\n    let rowStart, rowEnd;\n    if (imageY1 < imageY2) {\n      rowStart = imageY1;\n      rowEnd = imageY2;\n    } else {\n      rowStart = imageY2;\n      rowEnd = imageY1;\n    }\n\n    rowStart = clamp(rowStart, 0, raster_height - 1);\n    rowEnd = clamp(rowEnd, 0, raster_height - 1);\n    // iterate through image lines within the change in y of\n    // the edge line and find all intersections\n    for (let j = rowStart; j < rowEnd + 1; j++) {\n      const imageLineY = raster_ymax - pixel_height * j - pixel_height / 2;\n\n      const startsOnLine = y1 === imageLineY;\n      const endsOnLine = y2 === imageLineY;\n      const endsOffLine = !endsOnLine;\n\n      let xminOnLine, xmaxOnLine;\n      if (horizontal) {\n        if (edgeY === imageLineY) {\n          xminOnLine = startLng;\n          xmaxOnLine = endLng;\n        } else {\n          continue; // stop running calculations for this horizontal line because it doesn't intersect at all\n        }\n      } else if (vertical) {\n        /* we have to have a seprate section for vertical because of floating point arithmetic probs with get_inter...\" */\n        if (imageLineY >= edgeYMin && imageLineY <= edgeYMax) {\n          xminOnLine = startLng;\n          xmaxOnLine = endLng;\n        }\n      } else if (startsOnLine) {\n        // we know that the other end is not on the line because then it would be horizontal\n        xminOnLine = xmaxOnLine = x1;\n      } else if (endsOnLine) {\n        // we know that the other end is not on the line because then it would be horizontal\n        xminOnLine = xmaxOnLine = x2;\n      } else {\n        try {\n          xminOnLine = xmaxOnLine = x1 + (imageLineY - y1) / slope;\n        } catch (error) {\n          throw error;\n        }\n      }\n\n      // check to see if the intersection point is within the range of\n      // the edge line segment. If it is, add the intersection to the\n      // list of intersections at the corresponding index for that row\n      // in intersectionsByRow\n      if (\n        xminOnLine !== undefined &&\n        xmaxOnLine !== undefined &&\n        (horizontal || (xminOnLine >= startLng && xmaxOnLine <= endLng && imageLineY <= edgeYMax && imageLineY >= edgeYMin))\n      ) {\n        intersectionsByRow[j].push({\n          direction,\n          index: iedge,\n          edge,\n          // e.g: if there are 5 points (last repeated), there are 4 edges, with the last index being 3 (zero-indexed)\n          last_edge_in_ring: iedge === ring.length - 2,\n          endsOnLine,\n          endsOffLine,\n          horizontal,\n          startsOnLine,\n          vertical,\n          xmin: xminOnLine,\n          xmax: xmaxOnLine,\n          imageLineY\n        });\n      }\n    }\n  });\n\n  const half_pixel_width = pixel_width / 2;\n  const snap = prepareSnap(raster_xmin, pixel_width);\n\n  if (debug_level >= 1) console.log(\"[dufour-peyton-intersection] intersectionsByRow:\", intersectionsByRow);\n\n  intersectionsByRow.forEach((segmentsInRow, row_index) => {\n    if (segmentsInRow.length > 0) {\n      const clusters = clusterLineSegments(segmentsInRow);\n      const categorized = clusters.map(categorizeIntersection);\n      const [throughs, nonthroughs] = partition(categorized, item => item.through);\n\n      if (throughs.length % 2 === 1) {\n        if (debug_level >= 1) console.error(\"[dufour-peyton-intersection] throughs:\", JSON.stringify(throughs));\n        throw Error(\"throughs.length for \" + row_index + \" is odd with \" + throughs.length);\n      }\n\n      let insides = nonthroughs.map(intersection => [intersection.xmin, intersection.xmax]);\n\n      // sorts throughs from left to right in-place\n      throughs.sort((a, b) => a.xmin - b.xmin);\n\n      const couples = couple(throughs).map(couple => {\n        const [left, right] = couple;\n        return [left.xmin, right.xmax];\n      });\n\n      insides = insides.concat(couples);\n\n      /*\n        This makes sure we don't double count pixels.\n        For example, converts `[[0,10],[10,10]]` to `[[0,10]]`\n      */\n      insides = mergeRanges(insides);\n\n      insides.forEach(pair => {\n        const [xmin, xmax] = pair;\n\n        if (xmax - xmin < half_pixel_width) return;\n\n        // snap [xmin, xmax] in srs to raster coordinates\n        const [left, right] = snap(pair);\n\n        // intersection doesn't take up more than half of a pixel\n        if (left === right) return;\n\n        // skip because segment is beyond the right edge of the raster\n        if (left > raster_width) return;\n\n        // skip because segment is beyond the left edge of the raster\n        if (right <= 0) return;\n\n        const start_column_index = Math.max(left, 0);\n        const end_column_index = Math.min(right - 1, raster_width - 1);\n\n        if (per_row_segment) {\n          per_row_segment({\n            row: row_index,\n            columns: [start_column_index, end_column_index]\n          });\n        }\n\n        if (per_pixel) {\n          for (let column_index = start_column_index; column_index <= end_column_index; column_index++) {\n            per_pixel({ row: row_index, column: column_index });\n          }\n        }\n      });\n    }\n  });\n};\n","\"use strict\";\n\nmodule.exports = function eachPair(arr, callback) {\n  for (let i = 1; i < arr.length; i++) {\n    const a = arr[i - 1];\n    const b = arr[i];\n    callback([a, b], i - 1);\n  }\n};\n","\"use strict\";\nconst getPolygons = require(\"./get-polygons.js\");\nconst mergeConsecutiveRanges = require(\"./range/merge-consecutive.js\");\nconst rangeSort = require(\"./range/sort.js\");\nconst calculatePolygon = require(\"./calculate-polygon.js\");\n\nmodule.exports = function calculate({ geometry, raster_height, per_pixel, per_row_segment, debug_level = 0, ...rest }) {\n  const polys = getPolygons(geometry);\n\n  // collect inside segments by row for each polygons\n  const inside_rows_by_polygon = polys.map(polygon =>\n    calculatePolygon({\n      polygon,\n      raster_height,\n      debug_level,\n      ...rest\n    })\n  );\n  if (debug_level >= 1) console.log(\"[dufour-peyton-intersection] inside_rows_by_polygon:\", inside_rows_by_polygon);\n\n  const results = new Array(raster_height);\n  for (let i = 0; i < raster_height; i++) {\n    const insides = inside_rows_by_polygon\n      .map(polygon_rows => polygon_rows[i])\n      .filter(it => it !== undefined && it.length > 0)\n      .flat();\n    if (insides.length > 0) {\n      const sorted = rangeSort(insides);\n      const merged = mergeConsecutiveRanges(sorted);\n      results[i] = merged;\n    }\n  }\n\n  if (per_row_segment || per_pixel) {\n    results.forEach((row_segments, row_index) => {\n      if (row_segments) {\n        row_segments.forEach((seg, iseg) => {\n          if (per_row_segment) {\n            per_row_segment({ row: row_index, columns: seg });\n          }\n\n          if (per_pixel) {\n            const [start_column_index, end_column_index] = seg;\n            for (let column_index = start_column_index; column_index <= end_column_index; column_index++) {\n              per_pixel({ row: row_index, column: column_index });\n            }\n          }\n        });\n      }\n    });\n  }\n\n  return { rows: results };\n};\n","/**\n * @name overlaps\n * @description check if two ranges overlap\n * @param {Range} a \n * @param {Range} b \n * @returns {Boolean} result\n */\nmodule.exports = function overlaps(a, b) {\n  if (!Array.isArray(a)) throw new Error(\"[overlaps] a is not an array\");\n  if (!Array.isArray(b)) throw new Error(\"[overlaps] b is not an array\");  \n  return a[0] <= b[1] && b[0] <= a[1];\n};\n","\"use strict\";\n\n// This function takes in an array with an even number of elements and\n// returns an array that couples every two consecutive elements;\nmodule.exports = function couple(array) {\n  const couples = [];\n  const lengthOfArray = array.length;\n  for (let i = 0; i < lengthOfArray; i += 2) {\n    couples.push([array[i], array[i + 1]]);\n  }\n  return couples;\n};\n","\"use strict\";\nconst carveHoles = require(\"./range/multicut.js\");\nconst calculateRing = require(\"./calculate-ring\");\n\nmodule.exports = function calculatePolygon({ polygon, ...options }) {\n  const { debug_level = 0 } = options;\n  const [exterior, ...holes] = polygon.map(ring => calculateRing({ ring, ...options }));\n  if (debug_level >= 2) console.log(\"[dufour-peyton-intersection] exterior:\", exterior);\n\n  // for each row inside the polygon\n  // collect the relevant holes and then carve them out of that row\n  const result = exterior.map((row_insides, irow) => {\n    const row_holes = holes.map(hole_rows => hole_rows[irow]).flat();\n    return carveHoles(row_insides, row_holes);\n  });\n\n  return result;\n};\n","// This function takes in an array of number pairs and combines where there's overlap\nmodule.exports = function mergeRanges(ranges) {\n  const numberOfRanges = ranges.length;\n\n  if (numberOfRanges > 0) {\n    // Sort ranges by start, and if equal, by end\n    ranges.sort((a, b) => a[0] - b[0] || a[1] - b[1]);\n\n    const result = [];\n    let [currentStart, currentEnd] = ranges[0];\n\n    for (let i = 1; i < numberOfRanges; i++) {\n      const [start, end] = ranges[i];\n\n      // If the current range overlaps or is contiguous with the previous one\n      if (start <= currentEnd) {\n        currentEnd = Math.max(currentEnd, end); // Extend the range\n      } else {\n        // Push the current range to the result and start a new one\n        result.push([currentStart, currentEnd]);\n        currentStart = start;\n        currentEnd = end;\n      }\n    }\n\n    // Push the last range\n    result.push([currentStart, currentEnd]);\n\n    return result;\n  }\n};\n","\"use strict\";\n\nmodule.exports = function clamp(n, min, max) {\n  if (n < min) return min;\n  else if (n > max) return max;\n  return n;\n};\n","\"use strict\";\n// categorize line segments that intersect a horizontal line\n// categorize as through or not\nmodule.exports = function categorizeIntersection(segments) {\n  try {\n    let through, xmin, xmax;\n\n    const n = segments.length;\n\n    const first = segments[0];\n\n    if (n === 1) {\n      through = true;\n      xmin = first.xmin;\n      xmax = first.xmax;\n    } /* n > 1 */ else {\n      const last = segments[n - 1];\n      through = first.direction === last.direction;\n      xmin = Math.min(first.xmin, last.xmin);\n      xmax = Math.max(first.xmax, last.xmax);\n    }\n\n    if (xmin === undefined || xmax === undefined || through === undefined || isNaN(xmin) || isNaN(xmax)) {\n      throw Error(\"categorizeIntersection failed with xmin\", xmin, \"and xmax\", xmax);\n    }\n\n    return { xmin, xmax, through };\n  } catch (error) {\n    console.error(\"[categorizeIntersection] segments:\", segments);\n    console.error(\"[categorizeIntersection]\", error);\n    throw error;\n  }\n};\n","\"use strict\";\n\nconst roundDown = require(\"./round-down.js\");\n\n/**\n * @name prepareSnap\n * @description snap horizontal range in crs to model space\n * @private\n * @param {Number} raster_xmin\n * @param {Number} pixel_width\n * @return {([Number, Number]) => [Number, Number]}\n */\nmodule.exports = function prepareSnap(raster_xmin, pixel_width) {\n  return ([xmin, xmax]) => {\n    // use roundDown so 1.5 is rounded to 1 not 2\n    xmin = roundDown((xmin - raster_xmin) / pixel_width);\n    if (xmin === -0) xmin = 0;\n\n    xmax = Math.round((xmax - raster_xmin) / pixel_width);\n    if (xmax === -0) xmax = 0;\n\n    return [xmin, xmax];\n  };\n};\n","\"use strict\";\n\nmodule.exports = function checkRanges(rows) {\n  rows.forEach((ranges, irow) => {\n    for (let irange = 0; irange < ranges.length; irange++) {\n      const range = ranges[irange];\n      const [start, end] = range;\n      if (start > end) {\n        console.warn(\"[dufour-peyton-intersection] uh oh, encountered invalid range\", range, \"at row index\", irow, \"with ranges\", ranges);\n      }\n\n      for (let iother = irange + 1; iother < ranges.length; iother++) {\n        if (iother[0] <= end) {\n          console.warn(\"[dufour-peyton-intersection] encountered range problem on row index\", irow, \":\", ranges);\n        }\n      }\n    }\n  });\n};\n","\"use strict\";\n\n/**\n * @name partition\n * @description break items into two groups based on\n * whether they pass or fail a provided filter function\n * @param {Array} array\n * @param {Function} filter function\n * @returns {Array} partitioned items - [array_passed, array_unpassed]\n */\nmodule.exports = function partition(array, filter) {\n  const passed = [];\n  const unpassed = [];\n  const len = array.length;\n  for (let i = 0; i < len; i++) {\n    const item = array[i];\n    if (filter(item)) passed.push(item);\n    else unpassed.push(item);\n  }\n  return [passed, unpassed];\n};\n","const rangeCut = require(\"./cut.js\");\n\nmodule.exports = function carve(insides, holes) {\n  let results = insides;\n  holes.forEach(hole => {\n    results = results.map(pc => rangeCut(pc, hole)).flat();\n  });\n  return results;\n}\n","/**\n * @name mergeConsecutive\n * @description merges integer ranges if they touch.  ranges that are within 1 of each other count as consecutive and touching\n * @param {Array<Range>} ranges \n * @returns {Array<Range>} ranges\n */\nmodule.exports = function mergeConsecutive(ranges) {\n  const numberOfRanges = ranges.length;\n\n  if (numberOfRanges === 0) return [];\n\n  const firstRange = ranges[0];\n  let previousEnd = firstRange[1];\n  const result = [firstRange];\n  for (let i = 1; i < numberOfRanges; i++) {\n    const tempRange = ranges[i];\n    const [start, end] = tempRange;\n    if (start <= previousEnd + 1) {\n      result[result.length - 1][1] = Math.max(previousEnd, end);\n    } else {\n      result.push(tempRange);\n    }\n    previousEnd = end;\n  }\n  return result;\n};\n","\"use strict\";\n\nconst eachPolygon = require(\"./each-polygon.js\");\n\nmodule.exports = function getPolygons(geojson) {\n  const polygons = [];\n  eachPolygon(geojson, polygon => polygons.push(polygon));\n  return polygons;\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(44);\n"],"names":["categorizeIntersection","clamp","cluster","clusterLineSegments","calculate","calculateCore","couple","eachPair","eachPolygon","mergeRanges","mergeConsecutiveRanges","partition","prepareSnap","rangeContains","rangeCut","carveHoles","rangeOverlap","roundDown","dufour_peyton_intersection","rangeSort","module","exports","self","window","arr","isArray","Array","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","BigInt64Array","BigUint64Array","depth","part","items","newClusterTest","numberOfItems","length","clusters","i","item","push","error","console","checkRows","debug_level","raster_bbox","raster_height","raster_width","pixel_height","pixel_width","ring","xmin","ymin","xmax","ymax","every","it","Error","rows","per_row_segment","row","columns","irow","ranges","compare","sort","n","Math","round","lineSegments","numberOfEdges","debug","s","endsOffLine","firstCluster","firstSegment","lastCluster","lastSegment","last_edge_in_ring","index","endsOnLine","pop","concat","a","b","sign","range","hole","JSON","stringify","undefined","result","getDepth","geojson","callback","type","features","forEach","feature","geometries","geometry","coordinates","polygon","per_pixel","raster_xmin","raster_ymin","raster_xmax","raster_ymax","intersectionsByRow","edge","iedge","startPoint","endPoint","x1","y1","x2","y2","direction","horizontal","vertical","slope","edgeY","edgeYMin","min","edgeYMax","max","startLng","startLat","endLat","endLng","imageY1","imageY2","rowStart","rowEnd","j","imageLineY","startsOnLine","xminOnLine","xmaxOnLine","half_pixel_width","snap","log","segmentsInRow","row_index","categorized","map","throughs","nonthroughs","through","insides","intersection","couples","left","right","pair","start_column_index","end_column_index","column_index","column","getPolygons","calculatePolygon","rest","inside_rows_by_polygon","results","polygon_rows","filter","flat","sorted","merged","row_segments","seg","iseg","array","lengthOfArray","calculateRing","options","exterior","holes","row_insides","row_holes","hole_rows","numberOfRanges","currentStart","currentEnd","start","end","segments","first","last","isNaN","irange","warn","iother","passed","unpassed","len","pc","firstRange","previousEnd","tempRange","polygons","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__"],"sourceRoot":""}